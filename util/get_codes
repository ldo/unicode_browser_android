#!/usr/bin/python3
#+
# This script converts the system-installed Unicode tables into a Java
# source file (Unicode.java) that is compiled into the Android app.
# On Debian, the Unicode tables are installed as part of the “unicode-data”
# package, and are found in the /usr/share/unicode directory.
#
# This script is not run automatically as part of the build process,
# but is invoked manually. This is to ensure consistent builds, in
# case your system has a different version of the Unicode tables. The
# output of this script is already included in the source tree, so you
# only need to run it if your system has a newer version of the
# Unicode tables, and you want to update the source accordingly.
#
# Copyright 2013 Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

import sys
import re

data_file = "/usr/share/unicode/NamesList.txt"
versionstr = "@@@\tThe Unicode Standard "
out_file = "src/Unicode.java"

chars = {}
categories = []
with open(file = data_file, errors = "ignore") as data :
    charcode = None
    char_category = None
    eof = False
    line = data.readline().rstrip()
    if line.startswith(versionstr) :
        version = line[len(versionstr):]
        sys.stdout.write("Unicode version: “%s”\n" % version)
    else :
        raise AssertionError("first line doesn’t contain version")
    #end if
    while True :
        line = data.readline()
        if len(line) == 0 :
            eof = True
        #end if
        nextcharcode = None
        if not eof :
            line = line.rstrip()
            if len(line) != 0 :
                nextcharcode = re.match(r"[0-9A-F]+", line)
                if nextcharcode != None :
                    line = line[nextcharcode.end():]
                #end if
            #end if
        #end if
        if (eof or nextcharcode != None or line.startswith("@")) and charcode != None :
            include_it = True
            if charname.startswith("<") :
                if len(samechar) != 0 :
                    charname = samechar[0]
                    samechar = samechar[1:]
                else :
                    include_it = False
                #end if
            #end if
            if include_it :
                chars[charcode] = \
                    {
                        "name" : charname,
                        "category" : char_category,
                        "other_names" : samechar,
                        "similar" : likechar,
                    }
            #end if
            sys.stdout.write \
              (
                    "*%s U+%04X “%s” (%s) = (%s), like (%s)\n"
                %
                    (
                        ("IGNORE", "")[include_it],
                        charcode,
                        charname,
                        char_category,
                        "; ".join(samechar),
                        "; ".join("U+%04X" % c for c in likechar),
                    )
              )
            charcode = None
        #end if
        if eof :
            break
        if nextcharcode != None :
            charcode = int(nextcharcode.group(), 16)
            assert line.startswith("\t")
            charname = line[1:]
            samechar = []
            likechar = set()
        elif charcode != None and line.startswith("\t") :
            line = line[1:]
            if line.startswith("= ") :
                samechar.append(line[2:].replace("\"", ""))
            elif line.startswith("x ") :
                nextpos = 2
                while True :
                    nextlikecharcode = re.search(r"[0-9A-F]+", line[nextpos:])
                    if nextlikecharcode == None :
                        break
                    likecharcode = int(nextlikecharcode.group(), 16)
                    nextpos += nextlikecharcode.end()
                #end while
                likechar.add(likecharcode)
            else :
                pass # sys.stdout.write("Ignore line for U+%04X: %s\n" % (charcode, repr(line)))
            #end if
        elif line.startswith("@\t\t") :
            char_category = line[3:]
            if char_category not in categories :
                categories.append(char_category)
            #end if
        else :
            pass # sys.stdout.write("Ignore line: %s\n" % repr(line))
        #end if
    #end while
#end with

category_codes = {}
for i, name in enumerate(categories) :
    category_codes[name] = i
#end for
out = open(file = out_file, mode = "w", encoding = "utf-8")
out.write("package nz.gen.geek_central.unicode_browser;\n")
out.write \
  (
        "/*\n"
        "    Character table for Unicode Browser.\n"
        "    Automatically generated by get_codes script from\n"
        "    version %s of the Unicode database.\n"
        "\n"
        "    This file is in the public domain.\n"
        "*/\n"
        "\n"
    %
        version
  )
out.write("public class Unicode\n")
out.write("  {\n")
out.write("    public static final String Version = \"%s\";\n" % version)
out.write("    public static final int NrChars = %d;\n" % len(chars))
out.write("    public static final int NrCharCategories = %d;\n" % len(categories))
out.write("\n")

def encode_counted(s) :
    if len(s) > 127 :
        raise AssertionError("string %s too long to encode" % repr(s))
    #end if
    result = [len(s)]
    for c in s :
        c = ord(c)
        if c > 127 :
            raise AssertionError("character %d out of 7-bit range" % c)
        #end if
        result.append(c)
    #end for
    return \
        result
#end encode_counted

entries_per_char = 5 # nr entries in flattened CharTable per character
maxseglen = 8000 # as close as I can get to some safe upper limit

segcount = 0
def write_elts(name, elttype, data, segmented) :
    # writes out a list of data elements as a Java array with the specified
    # name and element type. segmented indicates the array is too large for
    # the Java compiler to handle, so it is broken into segments which are
    # then put into a two-dimensional array.
    global segcount
    max_per_line = (32, 4)[elttype == "String"] # reasonable number of array items to put on one source line
    format = ("%d", "\"%s\"")[elttype == "String"]
    if segmented :
        segnames = []
        i = 0
        curlinelen = None
        curseglen = None
        while True :
            if (
                    i == len(data)
                or
                    curseglen != None and curseglen == maxseglen
                or
                    curlinelen != None and curlinelen == max_per_line
            ) :
                if curlinelen != None :
                    out.write("\n")
                    curlinelen = None
                #end if
                if curseglen != None :
                    if i == len(data) or curseglen == maxseglen :
                        out.write("          };\n")
                        out.write("     } /*%s*/;\n" % segname)
                        curseglen = None
                    #end if
                #end if
                if i == len(data) :
                    break
            #end if
            if curseglen == None :
                segcount += 1
                segname = "DataSeg%d" % segcount
                segnames.append(segname)
                out.write("\n")
                out.write \
                  (
                        "    private static class %(segname)s\n"
                        "      {\n"
                        "        public static final %(elttype)s[] Data =\n"
                        "          {\n"
                    %
                        {
                            "segname" : segname,
                            "elttype" : elttype,
                        }
                  )
                curseglen = 0
            #end if
            if curlinelen == None :
                out.write("           ")
                curlinelen = 0
            #end if
            out.write(" " + format % data[i] + ",")
            curlinelen += 1
            curseglen += 1
            i += 1
        #end while
    #end if
    out.write("\n")
    out.write \
      (
            "    private static final %(elttype)s%(extradim)s[] %(name)s =\n"
            "        {\n"
        %
            {
                "elttype" : elttype,
                "name" : name,
                "extradim" : ("", "[]")[segmented],
            }
      )
    if segmented :
        out.write \
          (
            "".join
              (
                "            %s.Data,\n" % segname
                for segname in segnames
              )
          )
    else :
        i = 0
        curlinelen = None
        while True :
            if i == len(data) or curlinelen != None and curlinelen == max_per_line :
                if curlinelen != None :
                    out.write("\n")
                    curlinelen = None
                #end if
                if i == len(data) :
                    break
            #end if
            if curlinelen == None :
                out.write("           ")
                curlinelen = 0
            #end if
            out.write(" %d," % data[i])
            curlinelen += 1
            i += 1
        #end while
    #end if
    out.write("        };\n")
#end write_elts

out.write \
  (
    "    public static class CharRun\n"
    "      {\n"
    "        public final int StartCode, EndCode, StartIndex;\n"
    "\n"
    "        public CharRun\n"
    "          (\n"
    "            int StartCode,\n"
    "            int EndCode,\n"
    "            int StartIndex\n"
    "          )\n"
    "          {\n"
    "            this.StartCode = StartCode;\n"
    "            this.EndCode = EndCode;\n"
    "            this.StartIndex = StartIndex;\n"
    "          } /*CharRun*/\n"
    "\n"
    "      } /*CharRun*/;\n"
  )
out.write("\n")
out.write \
  (
    "  /* break out information returned into separate routines that can be invoked\n"
    "    on demand, to try to improve app startup speed. */\n"
  )
out.write("\n")
out.write \
  (
    "    public static int CharIndex\n"
    "      (\n"
    "        int Code\n"
    "      )\n"
    "      /* returns the index into the character tables for the character with the\n"
    "        specified code. Assumes there is such an entry! */\n"
    "      {\n"
    "        int Result;\n"
    "        for (int i = 0;;)\n"
    "          {\n"
    "            final CharRun ThisRun = CharRuns[i];\n"
    "            if (ThisRun.StartCode <= Code && ThisRun.EndCode >= Code)\n"
    "              {\n"
    "                Result = ThisRun.StartIndex + Code - ThisRun.StartCode;\n"
    "                break;\n"
    "              } /*if*/\n"
    "            ++i;\n"
    "          } /*for*/\n"
    "        return\n"
    "            Result;\n"
    "      } /*CharIndex*/\n"
  )
out.write("\n")
out.write \
  (
        "    public static int GetCharCode\n"
        "      (\n"
        "        int CharIndex\n"
        "      )\n"
        "      {\n"
        "        return\n"
        "            CharTable[CharIndex * %(nrentries)d / %(segsize)d][CharIndex * %(nrentries)d %% %(segsize)d];\n"
        "      } /*GetChar*/\n"
    %
        {
            "segsize" : maxseglen,
            "nrentries" : entries_per_char,
        }
  )
out.write("\n")
out.write \
  (
        "    public static int GetCharCategory\n"
        "      (\n"
        "        int CharIndex\n"
        "      )\n"
        "      {\n"
        "        return\n"
        "            CharTable[(CharIndex * %(nrentries)d + 1) / %(segsize)d][(CharIndex * %(nrentries)d + 1) %% %(segsize)d];\n"
        "      } /*GetCharCategory*/\n"
    %
        {
            "segsize" : maxseglen,
            "nrentries" : entries_per_char,
        }
  )
out.write("\n")
out.write \
  (
        "    public static String GetCharName\n"
        "      (\n"
        "        int CharIndex\n"
        "      )\n"
        "      {\n"
        "        return\n"
        "            GetName(CharTable[(CharIndex * %(nrentries)d + 2) / %(segsize)d][(CharIndex * %(nrentries)d + 2) %% %(segsize)d]);\n"
        "      } /*GetCharName*/\n"
    %
        {
            "segsize" : maxseglen,
            "nrentries" : entries_per_char,
        }
  )
out.write("\n")
out.write \
  (
        "    public static String[] GetCharOtherNames\n"
        "      (\n"
        "        int CharIndex\n"
        "      )\n"
        "      {\n"
        "        final int Base = CharIndex * %(nrentries)d;\n"
        "        final int OtherNamesStart = CharTable[(Base + 3) / %(segsize)d][(Base + 3) %% %(segsize)d];\n"
        "        final int NrOtherNames = OtherNameStarts[OtherNamesStart];\n"
        "        final String[] Result = new String[NrOtherNames];\n"
        "        for (int i = 1; i <= NrOtherNames; ++i)\n"
        "          {\n"
        "            Result[i - 1] = GetName(OtherNameStarts[OtherNamesStart + i]);\n"
        "          } /*for*/\n"
        "        return\n"
        "            Result;\n"
        "      } /*GetCharOtherNames*/\n"
    %
        {
            "segsize" : maxseglen,
            "nrentries" : entries_per_char,
        }
  )
out.write("\n")
out.write \
  (
        "    public static int[] GetCharLikeChars\n"
        "      (\n"
        "        int CharIndex\n"
        "      )\n"
        "      {\n"
        "        final int Base = CharIndex * %(nrentries)d;\n"
        "        final int LikeCharsStart = CharTable[(Base + 4) / %(segsize)d][(Base + 4) %% %(segsize)d];\n"
        "        final int NrLikeChars = LikeChars[LikeCharsStart];\n"
        "        final int[] Result = new int[NrLikeChars];\n"
        "        for (int i = 1; i <= NrLikeChars; ++i)\n"
        "          {\n"
        "            Result[i - 1] = LikeChars[LikeCharsStart + i];\n"
        "          } /*for*/\n"
        "        return\n"
        "            Result;\n"
        "      } /*GetCharLikeChars*/\n"
    %
        {
            "segsize" : maxseglen,
            "nrentries" : entries_per_char,
        }
  )
out.write("\n")
out.write \
  (
        "    private static String GetName\n"
        "      (\n"
        "        int Offset\n"
        "      )\n"
        "      /* returns a copy of the string starting at the specified offset in NameStrings. */\n"
        "      {\n"
        "        final int Strlen = NameStrings[Offset / %(segsize)d][Offset %% %(segsize)d];\n"
        "        final StringBuilder Result = new StringBuilder(Strlen);\n"
        "        for (int i = 1; i <= Strlen; ++i)\n"
        "          {\n"
        "            Result.setCharAt(i - 1, (char)((short)NameStrings[(Offset + i) / %(segsize)d][(Offset + i) %% %(segsize)d] & 255));\n"
        "          } /*for*/\n"
        "        return\n"
        "            Result.toString();\n"
        "      } /*GetName*/\n"
    %
        {
            "segsize" : maxseglen,
        }
  )
out.write("\n")
chartable = []
namestrings = []
othernamestarts = []
likechars = []
categorynamestarts = []
for category in categories :
    categorynamestarts.append(len(namestrings))
    namestrings.extend(encode_counted(category))
#end for
out.write \
  (
    "    public static String GetCategoryName\n"
    "      (\n"
    "        int CategoryCode\n"
    "      )\n"
    "      {\n"
    "        return\n"
    "            GetName(CategoryNameStarts[CategoryCode]);\n"
    "      } /*GetCategoryName*/\n"
  )
write_elts("CategoryNameStarts", "int", categorynamestarts, False)
for charcode in sorted(chars) :
    thischar = chars[charcode]
    chartable.extend \
      (
        [
            charcode,
            category_codes[thischar["category"]],
            len(namestrings), # start of name string
            len(othernamestarts), # start of other names
            len(likechars), # start of like chars
        ]
      )
    namestrings.extend(encode_counted(thischar["name"]))
    othernamestarts.append(len(thischar["other_names"]))
    for name in thischar["other_names"] :
        othernamestarts.append(len(namestrings))
        namestrings.extend(encode_counted(name))
    #end for
    likechars.append(len(thischar["similar"]))
    for otherchar in thischar["similar"] :
        likechars.append(otherchar)
    #end for
#end for
sys.stdout.write("len(NameStrings) = %d\n" % len(namestrings)) # debug
write_elts("CharTable", "int", chartable, True)
write_elts("NameStrings", "byte", namestrings, True)
write_elts("OtherNameStarts", "int", othernamestarts, False)
write_elts("LikeChars", "int", likechars, False)
out.write("\n")
out.write("    public static final CharRun[] CharRuns =\n")
out.write("      {\n")
charsiter = iter(sorted(chars.keys()))
prevcharcode = None
charindex = 0
while True :
    charcode = next(charsiter, None)
    if charcode == None or prevcharcode != None and charcode - prevcharcode != 1 :
        if prevcharcode != None :
            out.write \
              (
                "        new CharRun(%#0.4x, %#0.4x, %d),\n" % (startcharcode, prevcharcode, startcharindex)
              )
            prevcharcode = None
        #end if
        if charcode == None :
            break
    #end if
    if prevcharcode == None :
        startcharcode = charcode
        prevcharcode = charcode
        startcharindex = charindex
    #end if
    prevcharcode = charcode
    charindex += 1
#end while
out.write("      } /*CharRuns*/;\n")
out.write("\n")
out.write("  } /*Unicode*/;\n")
out.flush()
out.close()
